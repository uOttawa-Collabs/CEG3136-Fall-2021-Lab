C:\Users\wxx9248\OneDrive - University of Ottawa\CEG 3136\Lab\2\AlarmAssembler\alarm.lst - generated by MGTEK Assembler ASM12 V1.26 Build 144 for WIN32 (x86) - Fri Oct 15 14:12:09 2021

    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: alarm.asm (Alarm System Module)
    4:                                 ; Author: Gilbert Arbez - Hamzah Alghamdi(modified)
    5:                                 ; Date: Fall 2019
    6:                                 ;------------------------------------------------------
   10:                                 
   11:                                 ; Some definitions
   12:                                 ; Location of the register block
   13:          =00000000              Regblk:       equ    $0000 
   14:                                  INCLUDE sections.inc
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
    9:          =00000001              SECTIONS_DEFINED   EQU  1        ; prevents future inclusion of the file
   10:                                 
   11:                                 ; Define addresses of various sections
   12:          =00003000              VARIABLES EQU $3000   ; $3000 - $3FFF
   13:          =00002000              PROGRAM   EQU $2000  ; $2000 - $2FFF
   14:          =00002000              STACK     EQU $2000  ; $1000 - $1FFF
   15:                                 
   16:                                 ;----------------------------------------
   17:                                 ; Global Variable section
   18:                                 ; Use the DS - define storage directive
   19:                                 ;              to define space for 
   20:                                 ;              global variables and data
   21:                                 ;              structures.
   22:                                 ;----------------------------------------
   23:                                 globalVar SECTION
   24:          =00003000                      ORG VARIABLES   ; places section in RAM
   25:                                 ;-----------------------------------------
   26:                                 ; Code section
   27:                                 ; Enter assembly instructions (HCS12) to create
   28:                                 ; executable code.
   29:                                 ;-----------------------------------------
   30:                                 code_section SECTION
   31:          =00002000                      ORG PROGRAM  ; places section in RAM - simulates ROM
   32:                                 
   33:                                 ;------------------------------------------
   34:                                 ; Global constants
   35:                                 ; In simple programs (single module) global constants are 
   36:                                 ; simply placed at the end of code and not section is
   37:                                 ; explicitly defined.
   38:                                 ;--------------------------------------------
   39:                                 globalConst SECTION
   40:          =00002463                      ORG ENDCODE ;--ENDCODE is defined on the second pass of the assembler
   41:                                 
   42:                                 ;----------------------------------------------
   43:                                 ; Defining the start of the globalConst Section
   44:                                 ; The following should be added to the end of the 
   45:                                 ; main module
   46:                                 ;----------------------------------------------
   47:                                 ;       SWITCH code_section 
   48:                                 ;ENDCODE        
   49:                                 
   50:                                          ENDIF  ; End of conditional assembly
   15:                                  INCLUDE alarm.inc
    1:                                 ;---------------------------------
    2:                                 ; File: alarmSimul.inc
    3:                                 ; Description: Include file for Alarm System Simulation
    4:                                 ;              project
    5:                                 ;----------------------------------------------
    6:                                         IFNDEF ALARM_SIMUL_HDR  ; Start of conditional assembly
    7:          =00000001              ALARM_SIMUL_HDR   EQU   1        ; prevents future inclusion of the file
    8:                                 
    9:                                 ; for calculating wins
   10:          =000000FF              NOCHAR        equ    0xff
   11:          =00000007              BEL           equ    0x07
   12:          =00000001              TRUE          equ    1
   13:          =00000000              FALSE         equ    0
   14:          =00000005              NUMCODES      equ    5
   15:          =00000008              XWINSUM        equ   ('X'+'X'+'X')&$FF  ; sum of three X's
   16:          =000000ED              OWINSUM        equ   'O'+'O'+'O'        ; sum of three O's
   17:          =0000000A              NL             equ   $0a                ; NEWLINE
   18:          =0000000D              CR             equ   $0d                ; carriage return
   19:          =00000030              ASCII_CONV_NUM equ   $30                ; For converting digit to ASCII
   20:                                 
   21:                                          ENDIF  ; End of conditional assembly
   16:                                 
   17:                                 ; Dbug12 subroutines
   18:          =0000EE86              putchar        equ   $EE86
   19:          =0000EE84              getchar        equ   $EE84
   20:          =0000EE88              printf         equ   $EE88
   21:          =0000EEA6              writeEEByte    equ   $EEA6
   22:                                 
   23:                                         switch code_section
   24:                                 ;------------------------------------------------------
   25:                                 ; Alarm System Module
   26:                                 
   27:                                 ; Main routine
   28:                                 ; Variables: select - in register B (set by getchar)
   29:                                 ; Description: The main routine for running the game.
   30:                                 ;              Initialises things (via initgb) and the
   31:                                 ;              loops forever playing games.
   32:                                 ;------------------------------------------------------
   33:     2000 CF 2000                        lds #STACK       ; Not reflected in C
   34:     2003 07 27                          bsr inithw       ; initiliase the hardware
   35:     2005 16 2367                        jsr initKeyPad   ;  initKeyPad();
   36:     2008 16 2453                        jsr initSwitches ;  initSwithes();
   37:                                         ; byte select - in register B
   38:                                                         ;do
   39:     200B                        mainloop:                       ; {
   40:     200B CC 246D                        ldd #MENU          ;   printf(MENU);
   41:     200E 15 FB CE76                     jsr [printf,PCr] 
   42:     2012 16 239C                        jsr readKey        ;   select = readKey();
   43:     2015 37                             pshb ; save b
   44:     2016 33                             pulb
   45:     2017 C1 63                          cmpb #'c'          ;   if(select == 'c') configCodes();
   46:     2019 26 05                          bne mnElseif
   47:     201B 16 2062                        jsr configCodes
   48:     201E 20 09                          bra mnEndif
   49:     2020 C1 61                  mnElseif cmpb #'a'         ;   else if(select == 'a') enableAlarm();
   50:     2022 26 05                          bne mnElse
   51:     2024 16 21BC                        jsr enableAlarm
   52:     2027 20 00                          bra mnEndif
   53:     2029                        mnElse                     ;   else /*do nothing*/;
   54:     2029                        mnEndif:
   55:     2029 20 E0                          bra mainloop       ; } while(1);  // loop forever
   56:     202B 3F                             swi                ; never reach here - infinite loop
   57:                                 
   58:                                 ;------------------------------------------------------
   59:                                 ; Subroutine: inithw
   60:                                 ; No parameters
   61:                                 ; Variables: ptx - index register X
   62:                                 ;            pty - index register Y
   63:                                 ; Description: First setup up the microcontroller setting up the clock, 
   64:                                 ;             shutting down the COP watchdog timer, and initialising 
   65:                                 ;             the SCI serial interface. Initialises global variables also.
   66:                                 ;------------------------------------------------------
   67:     202C                        inithw:
   68:                                 ; -- Initialise the hardware
   69:                                 ; Initialise the Phase-Lock-Loop (se page 34 of Dragon 12 Manual
   70:                                 ;       The crystal freq. on the DRAGON12 Plus board is 8 MHz so the default bus speed is 2 MHz
   71:                                 ;       In order to set the bus speed higher than 4 MHz the PLL must be initialized
   72:                                 ;
   73:                                 ;       The math used to set the PLL frequency is:
   74:                                 ;        
   75:                                 ;       PLLCLK = CrystalFreq * 2 * (initSYNR+1) / (initREFDV+1)
   76:                                 ;       
   77:                                 ;       If CrystalFreq = 8Mhz on DRAGON12 Plus board
   78:                                 ;         initSYNR     = 5    PLL multiplier will be 6
   79:                                 ;         initREFDV    = 0    PLL divisor will be 1
   80:                                 
   81:                                 ;       PLLCLK = 4*2*6/1 = 48MHz
   82:                                 ;       The bus speed = PLLCLK / 2 = 24 MHz
   83:                                 ;
   84:                                 ;      
   85:                                 ;********PLL code for 24MHz bus speed from a 4/8/16 crystal
   86:     202C 1410                           sei
   87:     202E CE 0000                        ldx #Regblk
   88:     2031 0D E0 39 80                    bclr Clksel,x,%10000000  ; clear bit 7, clock derived from oscclk
   89:     2035 0C E0 3A 40                    bset Pllctl,x,%01000000  ; Turn PLL on, bit 6 =1 PLL on, bit 6=0 PLL off
   90:     2039 86 05                          ldaa #$05                ; 5+1=6 multiplier 
   91:     203B 6A E0 34                       staa Synr,x
   92:                                 ;        ldaa #$03                ; divisor=3+1=4, 16 *6 /4 = 24Mhz for 16 MHz crystal
   93:     203E 86 01                          ldaa #$01                ; divisor=1+1=2,  8 *6 /2 = 24Mhz for  8 MHz crystal
   94:                                 ;        ldaa #$00                ; divisor=0+1=1,  4 *6 /1 = 24Mhz for  4 MHz crystal
   95:     2040 6A E0 35                       staa Refdv,x
   96:     2043                        wait_b3:
   97:     2043 0F E0 37 08 FB                 brclr Crgflg,x, %00001000 wait_b3  ; Wait until bit 3 = 1
   98:     2048 0C E0 39 80                    bset Clksel,x, %10000000
   99:                                 
  100:                                         ; Setup Serial port
  101:     204C CC 009C                        ldd #156
  102:     204F 5C C8                          std Sc0bdh   ; Sets up the baud rate
  103:     2051 86 0C                          ldaa #$0c
  104:     2053 5A CB                          staa Sc0cr2  ; Enables serial interface
  105:                                         
  106:                                         ; Setup the data in the RAM
  107:                                         ; For the Configuration Module
  108:     2055 1803 0000 3002                 movw #0,alarmCode
  109:     205B 1803 03E8 3000                 movw #1000,mult
  110:     2061 3D                             rts
  111:                                 
  112:                                    switch globalConst
  113:                                 
  114:                                 ;-------------------------------------------------------------------------
  115:                                 ; Data Structures
  116:                                 ; The following data is stored in EEPROM 
  117:                                 ; Following is data array used by testWin 
  118:                                 ;   int alarmCodes[NUMCODES] = { 0x0000, 0xFFFF, 0xFFFF, 0xFFFF, 0xFFFF }; 
  119:                                 ;------------------------------------------------------
  120:     2463 0000 FFFF FFFF         alarmCodes dc.w $0000, $FFFF, $FFFF, $FFFF, $FFFF  ; note this will be updated in ROM
           2469 FFFF FFFF 
  121:                                 
  122:                                 ; Message strings
  123:     246D 43 45 47 33 31 33      MENU     dc.b   "CEG3136 Alarm",NL,CR,"c-Config a-Arm",NL,CR,$00
           2473 36 20 41 6C 61 72 
           2479 6D 0A 0D 63 2D 43 
           247F 6F 6E 66 69 67 20 
           2485 61 2D 41 72 6D 0A 
           248B 0D 00 
  124:     248D 0A 0D 00               NEWLINE  dc.b   NL,CR,$00
  125:                                 
  126:                                  
  127:                                 ;----------
  128:                                 ; Include other modules here
  129:                                 ;-----------
  130:                                  INCLUDE        config.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: config.asm - the CONFIGURATION Module
    4:                                 ; Author: Gilbert Arbez
    5:                                 ; Date: Fall 2010
    6:                                 ;------------------------------------------------------
    7:                                 
    8:                                         SWITCH code_section ; include in the code
    9:                                 ;-----------------------------------
   10:                                 ; Subroutine - configCodes
   11:                                 ; Parameters: none
   12:                                 ; Returns: nothing
   13:                                 ; Local Variables:   ix,  input, flag - on stack
   14:                                 ; Description: Gets user to select alarm code to update/disable. Calls
   15:                                 ;              setcode to update the alarm code.
   16:                                 ;------------------------------------------------------
   17:                                 ; Stack Usage
   18:                                         OFFSET 0 ; to setup offsets into stack
   19:     0000 +0001                  CFG_IX   DS.B 1   ; ix
   20:     0001 +0001                  CFG_INPUT DS.B 1  ; input
   21:     0002 +0001                  CFG_FLAG DS.B 1   ; flag
   22:     0003                        CFG_VARSIZE:
   23:     0003 +0002                  CFB_PR_D        DS.W 1  ; preserve D 
   24:     0005 +0002                  CFG_RA  DS.W 1  ; return address
   25:                                 
   26:     2062 3B                     configCodes: pshd
   27:                                       ; byte ix;  // index into array
   28:                                       ; byte input; // input from user.
   29:                                       ; byte flag;
   30:     2063 1B 9D                        leas -CFG_VARSIZE,SP
   31:     2065 16 20A9                cfg_if1: jsr enterMstCode ; if(enterMstCode())
   32:     2068 97                           tsta
   33:     2069 27 3A                        beq cfg_endif1
   34:     206B                        cfg_loop:               ;     do {
   35:     206B CC 249E                      ldd #CONFIGMSG    ;          printf(CONFIGMSG);
   36:     206E 15 FB CE16                   jsr [printf,PCr]
   37:     2072 16 239C                      jsr readKey ;          input = readKey();
   38:     2075 6B 81                        stab CFG_INPUT,SP ;
   39:     2077 1808 82 01                   movb #TRUE,CFG_FLAG,SP;      flag = TRUE;
   40:     207B                        cfg_if2:
   41:     207B A6 81                        ldaa CFG_INPUT,SP ;          if(input == 'a')
   42:     207D 81 61                        cmpa #'a'
   43:     207F 26 07                        bne cfg_elseif2
   44:     2081 86 00                        ldaa #0           ;               setcode(0);
   45:     2083 16 2108                      jsr setcode
   46:     2086 20 19                        bra cfg_endif2
   47:     2088                        cfg_elseif2:
   48:     2088 81 31                        cmpa #'1'         ;           else if( input>='1' && input <= '4')
   49:     208A 25 0A                        blo cfg_else2
   50:     208C 81 34                        cmpa #'4'
   51:     208E 22 06                        bhi cfg_else2
   52:     2090 80 30                        suba #ASCII_CONV_NUM  ;       {   ix = input-ASCII_CONV_NUM;
   53:     2092 07 74                        bsr setcode           ;           setcode(ix); }
   54:     2094 20 0B                        bra cfg_endif2
   55:     2096                        cfg_else2:              ;           else      
   56:     2096 CC 24B1                      ldd #CERRMSG      ;           { printf(CERRMSG);
   57:     2099 15 FB CDEB                   jsr [printf,PCr]  ;
   58:     209D 1808 82 00                   movb #FALSE,CFG_FLAG,SP ;       flag = FALSE; }
   59:     20A1                        cfg_endif2:
   60:     20A1 E7 82                        tst CFG_FLAG,SP   ;       } while(!flag);
   61:     20A3 27 C6                        beq cfg_loop
   62:     20A5                        cfg_endif1:
   63:     20A5 1B 83                        leas CFG_VARSIZE,SP
   64:     20A7 3A                           puld
   65:     20A8 3D                           rts
   66:                                 
   67:                                 ;--------------------------------
   68:                                 ; Subroutine: enterMstCode
   69:                                 ; Parameters: none
   70:                                 ; Returns: TRUE - valid code entered, FALSE otherwise - Acc A.
   71:                                 ; Description: Prompts user for the 4 digit master alarm code.
   72:                                 ;-------------------------------
   73:                                 ; Stack Usage
   74:                                         OFFSET 0 ; to setup offsets into stack
   75:     0000 +0001                  EMC_RETVAL  DS.B 1   ; retval
   76:     0001 +0001                  EMC_I       DS.B 1   ; i
   77:     0002 +0001                  EMC_INPUT   DS.B 1   ; input
   78:     0003 +0002                  EMC_ALARMCODE DS.W 1 ; alarmCode
   79:     0005 +0002                  EMC_MULT    DS.W 1   ; mult
   80:     0007                        EMC_VARSIZE:
   81:     0007 +0002                  EMC_PR_Y    DS.W 1   ; preserve Y
   82:     0009 +0002                  EMC_PR_X    DS.W 1   ; preserve X
   83:     000B +0001                  EMC_PR_B    DS.B 1   ; preserve B
   84:     000C +0002                  EMC_RA      DS.W 1   ; return address
   85:                                 
   86:     20A9 37                     enterMstCode pshb
   87:     20AA 34                        pshx
   88:     20AB 35                        pshy
   89:     20AC 1B 99                     leas -EMC_VARSIZE,SP
   90:     20AE 1808 80 00                movb #FALSE,EMC_RETVAL,SP  ; byte retval = FALSE;
   91:                                                               ; byte i;
   92:                                                               ; byte input;
   93:     20B2 1800 83 0000              movw #0,EMC_ALARMCODE,SP   ; int alarmCode = 0;
   94:     20B7 1800 85 03E8              movw #1000,EMC_MULT,SP     ; int mult = 1000;
   95:                                    
   96:     20BC CC 2490                   ldd #MSTCDMSG              ; printf(MSTCDMSG);
   97:     20BF 15 FB CDC5                jsr [printf, PCr]
   98:     20C3 69 81                     clr EMC_I,SP
   99:     20C5                        emc_for:                      ; for(i=0 ; i<4 ; i++)
  100:     20C5 16 239C                   jsr readKey                ; {
  101:     20C8 6B 82                     stab EMC_INPUT,SP          ;    input = readKey();
  102:     20CA                        emc_if1:
  103:     20CA 180F                      tba
  104:     20CC 16 2435                   jsr isdigit                ;    if(!isdigit(input))
  105:     20CF 97                        tsta
  106:     20D0 27 2E                     beq emc_endfor             ;         break;
  107:     20D2                        emc_else1:                    ;    else {
  108:     20D2 E6 82                     ldab EMC_INPUT,SP          ;       alarmCode = alarmCode + mult*(input-ASCII_CONV_NUM);
  109:     20D4 C0 30                     subb #ASCII_CONV_NUM
  110:     20D6 87                        clra
  111:     20D7 ED 85                     ldy  EMC_MULT,SP
  112:     20D9 13                        emul
  113:     20DA E3 83                     addd EMC_ALARMCODE,SP
  114:     20DC 6C 83                     std EMC_ALARMCODE,SP
  115:     20DE EC 85                     ldd EMC_MULT,SP            ;       mult = mult/10;
  116:     20E0 CE 000A                   ldx #10
  117:     20E3 1810                      idiv
  118:     20E5 6E 85                     stx EMC_MULT,SP
  119:     20E7 8E 0000                emc_if2: cpx #0               ;       if(mult == 0)  {
  120:     20EA 26 0B                     bne emc_endif2
  121:     20EC FC 2463                emc_if3: ldd alarmCodes      ;            if(alarmCode == alarmCodes[0]) 
  122:     20EF AC 83                     cpd EMC_ALARMCODE,SP
  123:     20F1 26 04                     bne emc_endif3
  124:     20F3 1808 80 01                movb #TRUE,EMC_RETVAL,SP   ;                 retval = TRUE;
  125:     20F7                        emc_endif3:
  126:     20F7                        emc_endif2:                   ;       }
  127:     20F7                        emc_endif1:                   ;    }
  128:     20F7 A6 81                     ldaa EMC_I,SP
  129:     20F9 42                        inca
  130:     20FA 6A 81                     staa EMC_I,SP
  131:     20FC 81 04                     cmpa #4
  132:     20FE 25 C5                     blo emc_for
  133:     2100                        emc_endfor:                   ; }
  134:     2100 A6 80                     ldaa EMC_RETVAL,SP         ; return(retval);
  135:     2102 1B 87                     leas EMC_VARSIZE,SP
  136:     2104 31                        puly
  137:     2105 30                        pulx
  138:     2106 33                        pulb
  139:     2107 3D                        rts
  140:                                 
  141:                                 ;---------------------------------
  142:                                 ; Subroutine; setcode (ix)
  143:                                 ; Parameters
  144:                                 ;        ix - in accumulator a
  145:                                 ; Local variables
  146:                                 ;        flag, i, input, digit, alarmCode, mult - on stack
  147:                                 ; Description: Prompts user for a 4 digit alarm code to
  148:                                 ;              update the alarm code at index ix. If 'd'
  149:                                 ;              is entered the alarm code is disabled.  It
  150:                                 ;              is not allowed to diable the master
  151:                                 ;              alarm code.void setcode(byte ix).
  152:                                 ;------------------------------------------------------
  153:                                 ; Stack Usage
  154:                                         OFFSET 0 ; to setup offsets into stack
  155:     0000 +0001                  SETC_IX   DS.B 1  ; ix
  156:     0001 +0001                  SETC_FLAG DS.B 1  ; flag
  157:     0002 +0001                  SETC_I    DS.B 1  ; i
  158:     0003 +0001                  SETC_INPUT DS.B 1 ; input 
  159:     0004 +0002                  SETC_DIGIT DS.W 1 ; digit
  160:     0006 +0002                  SETC_ALARMCODE DS.W 1  ; alarmCode
  161:     0008 +0002                  SETC_MULT DS.W 1  ; mult
  162:     000A                        SETC_VARSIZE:
  163:     000A +0002                  SETC_PR_D DS.W 1        ; preserve D
  164:     000C +0002                  SETC_PR_X DS.W 1        ; preserve D 
  165:     000E +0002                  SETC_PR_Y DS.W 1        ; preserve D  
  166:     0010 +0002                  SETC_RA DS.W 1  ; return address
  167:                                 
  168:     2108 35                     setcode: pshy       ; {
  169:     2109 34                              pshx
  170:     210A 3B                              pshd
  171:     210B 1B 96                        leas -SETC_VARSIZE,SP   ; make room for variables
  172:     210D 180B 01 0001                 movb #TRUE, SETC_FLAG   ; byte flag = TRUE;
  173:                                                               ; byte i;
  174:                                                               ; byte input;
  175:                                                               ;int digit;
  176:     2112 1800 86 0000                 movw #0,SETC_ALARMCODE,SP   ; int alarmCode=0;
  177:     2117 1800 88 03E8                 movw #1000,SETC_MULT,SP ; int mult=1000; // multiplier
  178:     211C 6A 80                        staa SETC_IX,SP         ; save parameter value
  179:     211E                        setc_loop:                    ; do {
  180:     211E CC 24BD                      ldd #GET_CODE_MSG       ;      printf(GET_CODE_MSG);
  181:     2121 15 FB CD63                   jsr [printf, PCr]
  182:     2125 69 82                        clr SETC_I,SP           ;      for(i=0 ; i< 4 ; i++)
  183:     2127                        setc_for:                     ;      {
  184:     2127 16 239C                      jsr readKey             ;         input = readKey();
  185:     212A 6B 83                        stab SETC_INPUT,SP
  186:     212C C1 64                  setc_if cmpb #'d'             ;         if(input == 'd')
  187:     212E 26 1C                        bne setc_elseif         ;         { 
  188:     2130 A6 80                  setc_if2 ldaa SETC_IX,SP      ;            if(ix == 0) 
  189:     2132 81 00                        cmpa #0
  190:     2134 26 09                        bne setc_else2
  191:     2136 CC 24CB                      ldd #ERR_MST_MSG        ;               printf(ERR_MST_MSG);
  192:     2139 15 FB CD4B                   jsr [printf,PCr]
  193:     213D 20 0B                        bra setc_endif2
  194:     213F                        setc_else2                    ;            else {
  195:     213F 1800 86 FFFF                 movw #$ffff,SETC_ALARMCODE,SP ;            alarmCode = 0xffff;
  196:     2144 1808 81 00                   movb #FALSE,SETC_FLAG,SP;                  flag = FALSE;
  197:     2148 20 3E                        bra setc_endfor          ;                 break; 
  198:     214A                        setc_endif2                   ;             }
  199:     214A 20 33                        bra setc_endif          ;         }
  200:     214C                        setc_elseif:
  201:     214C A6 83                        ldaa SETC_INPUT,SP      ;         else if(isdigit(input))
  202:     214E 16 2435                      jsr isdigit
  203:     2151 97                           tsta
  204:     2152 27 22                        beq setc_else
  205:     2154 E6 83                        ldab SETC_INPUT,SP      ;         {  digit = input - ASCII_CONV_NUM;
  206:     2156 C0 30                        subb #ASCII_CONV_NUM
  207:     2158 87                           clra
  208:     2159 6C 84                        std SETC_DIGIT,SP       ;            alarmCode = alarmCode + digit * mult;
  209:     215B ED 88                        ldy SETC_MULT,SP
  210:     215D 13                           EMUL                    ; // Result digit*mult is in D
  211:     215E E3 86                        addd SETC_ALARMCODE,SP
  212:     2160 6C 86                        std SETC_ALARMCODE,SP
  213:     2162 EC 88                        ldd SETC_MULT,SP        ;            mult = mult/10;
  214:     2164 CE 000A                      ldx #10
  215:     2167 1810                         idiv
  216:     2169 6E 88                        stx SETC_MULT,SP
  217:     216B 8E 0000                      cpx #0                  ;            if(mult == 0)
  218:     216E 26 0F                        bne setc_endif          ;             
  219:     2170 1808 81 00                   movb #FALSE,SETC_FLAG,SP ;                flag = FALSE;
  220:     2174 20 09                        bra setc_endif          ;         }
  221:     2176                        setc_else:                    ;         else {
  222:     2176 CC 24B1                      ldd #CERRMSG            ;                printf(CERRMSG);
  223:     2179 15 FB CD0B                   jsr [printf, PCr]
  224:     217D 20 09                        bra setc_endfor         ;                break;
  225:                                                               ;         }
  226:     217F                        setc_endif:
  227:     217F A6 82                        ldaa SETC_I,SP
  228:     2181 42                           inca
  229:     2182 6A 82                        staa SETC_I,SP
  230:     2184 81 04                        cmpa #4
  231:     2186 25 9F                        blo setc_for 
  232:     2188                        setc_endfor:                       ;   }
  233:     2188 E7 81                        tst SETC_FLAG,SP        ; } while(flag);
  234:     218A 26 92                        bne setc_loop
  235:     218C A6 80                        lda SETC_IX,SP   ; writeToEE( (int) &alarmCodes[ix], alarmCode);
  236:     218E 48                           lsla  ; double index value - 2 bytes/element
  237:     218F CE 2463                      ldx #alarmCodes
  238:     2192 1A E4                        leax a,x
  239:     2194 EC 86                        ldd SETC_ALARMCODE,SP
  240:     2196 07 06                        bsr writeToEE
  241:     2198 1B 8A                        leas SETC_VARSIZE,SP    ; skip over variables
  242:     219A 3A                           puld                    ; restore registers
  243:     219B 30                           pulx
  244:     219C 31                           puly
  245:     219D 3D                           rts
  246:                                 ;---------------------------------
  247:                                 ; Subroutine: writeToEE()
  248:                                 ; Parameters: address - in x register
  249:                                 ;             alarmCode    - in d register
  250:                                 ; Variables: none
  251:                                 ; Description:
  252:                                 ;     Write the alarm code in EEProm. writeEEByte() is a 
  253:                                 ;     function avaible in Debug12.
  254:                                 ;------------------------------------------------------
  255:                                 ; Stack Usage
  256:                                         OFFSET 0 ; to setup offsets into stack
  257:     0000 +0002                  WREE_PR_D DS.W 1        ; preserve D - alarmCode
  258:     0002 +0002                  WREE_PR_X DS.W 1        ; preserve X - address 
  259:     0004 +0002                  WREE_RA DS.W 1  ; return address
  260:                                 
  261:     219E 34                     writeToEE:  pshx
  262:     219F 3B                                 pshd
  263:     21A0 E6 80                              ldab WREE_PR_D,SP   ;  writeEEByte(address, (byte)((alarmCode&0xff00)>>8) );
  264:     21A2 3B                                 pshd   ; save argument on stack
  265:     21A3 B7 54                              tfr x,d ; first argument passed in D
  266:     21A5 4B FB CCFD                         call [writeEEByte, PCr]
  267:     21A9 30                                 pulx  ; remove argument
  268:     21AA EE 82                              ldx WREE_PR_X,SP     ; get address
  269:     21AC E6 81                              ldab WREE_PR_D+1,SP  ; writeEEByte(address+1, (byte)(alarmCode&0xff) );
  270:     21AE 3B                                 pshd  ; save argument on stack
  271:     21AF B7 54                              tfr x,d ; first argument passed in D
  272:     21B1 C3 0001                            addd #1 ; address+1
  273:     21B4 4B FB CCEE                         call [writeEEByte, PCr]
  274:     21B8 30                                 pulx   ; remove argument
  275:     21B9 3A                                 puld   ; restore D
  276:     21BA 30                                 pulx   ; restore X
  277:     21BB 3D                                 rts
  278:                                         
  279:                                    switch globalConst
  280:     2490 4D 61 73 74 65 72      MSTCDMSG    dc.b "Master code",NL,CR,$00
           2496 20 63 6F 64 65 0A 
           249C 0D 00 
  281:     249E 61 3A 6D 73 74 72      CONFIGMSG   dc.b "a:mstr 1-4:other",NL,CR,$00
           24A4 20 31 2D 34 3A 6F 
           24AA 74 68 65 72 0A 0D 
           24B0 00 
  282:     24B1 42 61 64 20 65 6E      CERRMSG     dc.b "Bad entry",NL,CR,$00
           24B7 74 72 79 0A 0D 00 
  283:     24BD 43 6F 64 65 20 6F      GET_CODE_MSG dc.b "Code or 'd'",NL,CR,$00
           24C3 72 20 27 64 27 0A 
           24C9 0D 00 
  284:     24CB 43 61 6E 6E 6F 74      ERR_MST_MSG dc.b "Cannot disable",NL,CR,$00
           24D1 20 64 69 73 61 62 
           24D7 6C 65 0A 0D 00 
  285:                                 
  131:                                  INCLUDE        armed.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: armed.asm
    4:                                 ; Description: The Armed Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:          =00000BB8              ARMDELAY  equ 3000; 15000
   11:          =000003E8              BEEPDELAY equ 1000
   12:                                 
   13:                                 ;-------------------------------------------
   14:                                 ; Subroutine: enableAlarm
   15:                                 ; Parameters: none
   16:                                 ; Returns: nothing
   17:                                 ; Variables
   18:                                 ;       input, codeValid, delayFlag - on stack
   19:                                 ; Description:
   20:                                 ;     Gets user to enter a valid alarm code to arm
   21:                                 ;     the alarm system.  Delays 15 seconds (to allow user
   22:                                 ;     to leave; the alarm can be disarmed during this period),
   23:                                 ;     monitors for trigger events (a, b, c, d, e).  When 'a'
   24:                                 ;     is detected, 15 seconds are allowed to enter an alarm code to
   25:                                 ;     disarm the system; otherwise the alarm is triggered. For other
   26:                                 ;     trigger events, the alarm is triggered instantly.  The alarm
   27:                                 ;     system can be turned off after being triggered with an alarm
   28:                                 ;     code.
   29:                                 ;------------------------------------------------------
   30:                                 ; Stack Usage:
   31:                                         OFFSET 0  ; to setup offset into stack
   32:     0000 +0001                  EAL_INPUT      DS.B 1  ; input
   33:     0001 +0001                  EAL_CODEVALID  DS.B 1 ; codeValid
   34:     0002 +0001                  EAL_DELAYFLAG  DS.B 1 ; delayFlag
   35:     0003                        EAL_VARSIZE:
   36:     0003 +0002                  EAL_PR_D              DS.W 1 ; preserve D
   37:     0005 +0002                  EAL_RA         DS.W 1 ; return address
   38:                                 
   39:     21BC 3B                     enableAlarm:  pshd
   40:     21BD 1B 9D                     leas  -EAL_VARSIZE,SP        ;byte input;  // input from user
   41:                                                                 ;byte codeValid;  // valid alarm code found
   42:                                                                 ;byte delayFlag;
   43:                                    ;// Get a valid alarm code to arm the system
   44:     21BF CC 24DC                   ldd #CODEMSG                 ; printf(CODEMSG);
   45:     21C2 15 FB CCC2                jsr [printf, PCr]
   46:     21C6 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   47:     21CA                        eal_while1:
   48:     21CA E7 81                     tst EAL_CODEVALID,SP         ; while(!codeValid) 
   49:     21CC 26 0E                     bne eal_endwhile1            ; {
   50:     21CE 16 239C                   jsr readKey                  ;   input = readKey();
   51:     21D1 6B 80                     stab EAL_INPUT,SP
   52:     21D3 180F                      tba
   53:     21D5 16 229F                   jsr checkCode                ;     codeValid = checkCode(input);
   54:     21D8 6A 81                     staa EAL_CODEVALID,SP
   55:     21DA 20 EE                     bra eal_while1
   56:     21DC                        eal_endwhile1                   ; }
   57:                                 
   58:     21DC CC 24E3                   ldd #ARMING                   ; printf(ARMING);
   59:     21DF 15 FB CCA5                jsr [printf,PCr]
   60:                                    ; // Delay 1500 ms, i.e. 15 seconds
   61:     21E3 CC 0BB8                   ldd #ARMDELAY                 ; setDelay(ARMDELAY);
   62:     21E6 16 240F                   jsr setDelay
   63:     21E9 1808 81 00                movb #FALSE,EAL_CODEVALID,SP ; codeValid = FALSE;
   64:     21ED 1808 82 00                movb #FALSE,EAL_DELAYFLAG,SP ; delayFlag = FALSE;
   65:     21F1                        eal_while2:                     ; while(!delayFlag) 
   66:     21F1 E7 82                     tst EAL_DELAYFLAG,SP         ; {
   67:     21F3 26 28                     bne eal_endwhile2
   68:     21F5 16 2413                   jsr polldelay                ;   delayFlag = delay(); 
   69:     21F8 6A 82                     staa EAL_DELAYFLAG,SP
   70:     21FA 16 2372                   jsr pollreadKey              ;   input = pollreadKey();  // check if code entered to disarm
   71:     21FD 6B 80                     stab EAL_INPUT,SP
   72:     21FF 180F                      tba
   73:     2201                        eal_if1:
   74:     2201 81 23                     cmpa #'#'                    ;   if(isdigit(input) || input == '#') 
   75:     2203 27 08                     beq eal_blk1
   76:     2205 16 2435                   jsr isdigit
   77:     2208 97                        tsta
   78:     2209 26 02                     bne eal_blk1
   79:     220B 20 0E                     bra eal_endif1   
   80:     220D                        eal_blk1:                       ;    {
   81:     220D A6 80                     ldaa EAL_INPUT,SP            
   82:     220F 16 229F                   jsr checkCode                ;        codeValid = checkCode(input);
   83:     2212 6A 81                     staa EAL_CODEVALID,SP
   84:     2214                        eal_if2:
   85:     2214 97                        tsta                         ;        if(codeValid) 
   86:     2215 27 04                     beq eal_endif2
   87:     2217 1808 82 01                movb #TRUE,EAL_DELAYFLAG,SP  ;            delayFlag = TRUE;  // break out of loop
   88:     221B                        eal_endif2:
   89:     221B                        eal_endif1:                     ;    }
   90:     221B 20 D4                     bra eal_while2               
   91:     221D                        eal_endwhile2                   ; }
   92:                                 
   93:                                    ;// Loop to monitor trigger events and alarm code to disable
   94:                                    ;// codeValid is TRUE if valid alarm code entered during delay
   95:     221D                        eal_if3:                        ; if(!codeValid)
   96:     221D E7 81                     tst EAL_CODEVALID,SP
   97:     221F 26 07                     bne eal_endif3
   98:     2221 CC 24F4                   ldd #ARMED                   ;        printf(ARMED)
   99:     2224 15 FB CC60                jsr [printf, PCr]
  100:     2228                        eal_endif3:
  101:     2228                        eal_while3                      ;  while(!codeValid)
  102:     2228 E7 81                     tst EAL_CODEVALID,SP         ; {
  103:     222A 26 6F                     bne eal_endwhile3
  104:     222C 16 2372                   jsr pollReadKey              ;    input = pollReadKey();
  105:     222F 6B 80                     stab EAL_INPUT,SP
  106:     2231 180F                      tba
  107:     2233                        eal_elseif
  108:     2233 81 23                     cmpa #'#'                    ;    if(isdigit(input) || input == '#') 
  109:     2235 27 08                     beq eal_blk2
  110:     2237 16 2435                   jsr isdigit
  111:     223A 97                        tsta
  112:     223B 26 02                     bne eal_blk2
  113:     223D 20 08                     bra eal_elseifA  
  114:     223F                        eal_blk2:      
  115:     223F A6 80                     ldaa EAL_INPUT,SP             ;        codeValid = checkCode(input);
  116:     2241 07 5C                     bsr checkCode                
  117:     2243 6A 81                     staa EAL_CODEVALID,SP 
  118:     2245 20 52                     bra eal_endelseif    
  119:     2247                        eal_elseifA:
  120:     2247 16 245F                   jsr getSwStatus               ;   else if(getSwStatus() & 0b00000001) // Front door opened
  121:     224A 84 01                     anda #%00000001
  122:     224C 27 3D                     beq eal_elseifB               ;   {
  123:     224E CC 2504                   ldd #DISARMING                ;      printf(DISARMING);
  124:     2251 15 FB CC33                jsr [printf, PCr]
  125:     2255 CC 0BB8                   ldd #ARMDELAY                 ;      setDelay(ARMDELAY);
  126:     2258 16 240F                   jsr setDelay
  127:     225B                        eal_while4:                      ;      while(!codeValid)
  128:     225B A6 81                     ldaa EAL_CODEVALID,SP         ;      {
  129:     225D 26 2A                     bne eal_endwhile4 
  130:     225F                        eal_if4:
  131:     225F 16 2413                   jsr pollDelay                 ;         if(pollDelay())
  132:     2262 97                        tsta  
  133:     2263 27 09                     beq eal_else4                 ;         { 
  134:     2265 16 2320                   jsr triggerAlarm              ;            triggerAlarm();
  135:     2268 1808 81 01                movb #TRUE,EAL_CODEVALID,SP   ;            codeValid = TRUE;           
  136:     226C 20 19                     bra eal_endif4                ;         }
  137:     226E                        eal_else4                        ;         else {
  138:     226E 16 2372                   jsr pollReadKey               ;            input = pollReadKey();  // check if alarm code entered to disarm
  139:     2271 6B 80                     stab EAL_INPUT,SP
  140:     2273                        eal_if5:
  141:     2273 180F                      tba                           ;            if(isdigit(input) || input == '#')
  142:     2275 81 23                     cmpa #'#' 
  143:     2277 27 08                     beq eal_blk3
  144:     2279 16 2435                   jsr isdigit
  145:     227C 97                        tsta
  146:     227D 26 02                     bne eal_blk3
  147:     227F 20 06                     bra eal_endif5   
  148:     2281                        eal_blk3:  
  149:     2281 A6 80                     ldaa EAL_INPUT,SP
  150:     2283 07 1A                     bsr checkCode                ;                 codeValid = checkCode(input);
  151:     2285 6A 81                     staa EAL_CODEVALID,SP 
  152:     2287                        eal_endif5:
  153:     2287                        eal_endif4:                     ;          }
  154:     2287 20 D2                     bra eal_while4
  155:     2289                        eal_endwhile4:                  ;        }
  156:     2289                        eal_endelseifA                  ;      }
  157:     2289 20 0E                     bra eal_endelseif;      
  158:     228B                        eal_elseifB:
  159:     228B 16 245F                   jsr getSwStatus              ;      else if(getSwStatus() & 0b11111110) // other door/window opened
  160:     228E 84 FE                     anda #%11111110              ;      
  161:     2290 27 07                     beq eal_endelseifB           ;      {
  162:     2292 16 2320                   jsr triggerAlarm             ;          triggerAlarm();
  163:     2295 1808 81 01                movb #TRUE,EAL_CODEVALID,SP  ;          codeValid = TRUE;
  164:     2299                        eal_endelseifB:                 ;      }
  165:                                    ;    // ignore all other input
  166:     2299                        eal_endelseif:
  167:     2299 20 8D                      bra eal_while3
  168:     229B                        eal_endwhile3                   ; }
  169:     229B 1B 83                      leas EAL_VARSIZE,SP
  170:     229D 3A                         puld
  171:     229E 3D                         rts
  172:                                 
  173:                                 
  174:                                 ;------------------------------------------------------
  175:                                 ; Subroutine: checkCode
  176:                                 ; Parameters: input - accumulator A
  177:                                 ; Returns: TRUE when a valid alarm code is detected, FALSE otherwise - stored in 
  178:                                 ;          accumulator A
  179:                                 ; Local Variables: retval - on stack
  180:                                 ; Global Variables:
  181:                                 ;       mult - initilased to 1000 in inithw (Alarm System Module)
  182:                                 ;       alarmCode - initialised to 0 in inithw (Alarm System Module)
  183:                                 ; Descriptions: Creates alarm code using digits entered until
  184:                                 ;               4 digits are seen. After 4th digit, see if
  185:                                 ;               alarm code is valid using isCodeValid().
  186:                                 ;------------------------------------------------------
  187:                                 ; Stack usage
  188:                                         OFFSET 0
  189:     0000 +0001                  CKC_INPUT  DS.B 1 ; parameter input
  190:     0001 +0001                  CKC_RETVAL DS.B 1 ; variable retval
  191:     0002                        CKC_VARSIZE
  192:     0002 +0001                  CKC_PR_B          DS.B 1 ; preserve B
  193:     0003 +0002                  CKC_PR_X   DS.W 1 ; preserve X
  194:     0005 +0002                  CKC_PR_Y   DS.W 1 ; preserve Y
  195:     0007 +0002                  CKC_RA    DS.W 1 ; return address
  196:                                 
  197:     229F 35                     checkCode: pshy
  198:     22A0 34                        pshx
  199:     22A1 37                        pshb
  200:     22A2 1B 9E                     leas -CKC_VARSIZE,SP       
  201:                                                               ; static int mult = 1000; // current multiplier of digit
  202:                                                               ; static int alarmCode = 0;   // alarm code value
  203:     22A4 1808 81 00                movb #FALSE,CKC_RETVAL,SP  ; byte retval = FALSE;
  204:     22A8 6A 80                     staa CKC_INPUT,SP          ; save paramater value
  205:                                    
  206:     22AA 16 2435                   jsr isdigit                ; if(isdigit(input))
  207:     22AD 97                        tsta
  208:     22AE 27 36                     beq ckc_else               ; {
  209:     22B0 A6 80                     ldaa CKC_INPUT,SP          ;    alarmCode = alarmCode + (input-ASCII_CONV_NUM)*mult
  210:     22B2 80 30                     suba #ASCII_CONV_NUM
  211:     22B4 180E                      tab                        
  212:     22B6 87                        clra
  213:     22B7 FD 3000                   ldy mult
  214:     22BA 13                        emul                       ; //*mult - result in D
  215:     22BB F3 3002                   addd alarmCode
  216:     22BE 7C 3002                   std alarmCode
  217:     22C1 FC 3000                   ldd mult                   ;    mult = mult/10;
  218:     22C4 CE 000A                   ldx #10
  219:     22C7 1810                      idiv
  220:     22C9 7E 3000                   stx mult
  221:     22CC FC 3000                   ldd mult                   ;    if(mult == 0) 
  222:     22CF 26 13                     bne ckc_endif1             ;    {
  223:     22D1 FC 3002                   ldd alarmcode              ;
  224:     22D4 07 24                     bsr isCodeValid            ;       retval = isCodeValid(alarmCode);
  225:     22D6 6A 81                     staa CKC_RETVAL,SP
  226:     22D8 CC 0000                   ldd #0                     ;       alarmCode = 0;
  227:     22DB 7C 3002                   std alarmCode 
  228:     22DE CC 03E8                   ldd #1000                  ;       mult = 1000;
  229:     22E1 7C 3000                   std mult     
  230:     22E4                        ckc_endif1:                   ;     }
  231:     22E4 20 0C                     bra ckc_endif              ; }
  232:     22E6                        ckc_else:                     ; else {
  233:     22E6 CC 0000                   ldd #0                     ;       alarmCode = 0;
  234:     22E9 7C 3002                   std alarmCode 
  235:     22EC CC 03E8                   ldd #1000                  ;       mult = 1000;
  236:     22EF 7C 3000                   std mult                   ; }
  237:     22F2                        ckc_endif:
  238:                                    
  239:     22F2 A6 81                     ldaa CKC_RETVAL,SP         ; return(retval);
  240:                                    ; Restore registers and stack
  241:     22F4 1B 82                     leas CKC_VARSIZE,SP
  242:     22F6 33                        pulb
  243:     22F7 30                        pulx
  244:     22F8 31                        puly
  245:     22F9 3D                        rts      
  246:                                 
  247:                                 
  248:                                 ;------------------------------------------------------
  249:                                 ; Subroutine: isCodeValid
  250:                                 ; Parameters: alarmCode stored in register D
  251:                                 ; Local Variables
  252:                                 ;   ptr - pointer to array - in register X
  253:                                 ;   cnt, retval - on the stack.
  254:                                 ; Returns: TRUE/FALSE - Returned in accumulator A 
  255:                                 ; Description: Checks to see if alarm code is in the
  256:                                 ;              alarmCodes array.
  257:                                 ;------------------------------------------------------
  258:                                 
  259:                                 ; Stack usage
  260:                                         OFFSET 0
  261:     0000 +0002                  CDV_ALARMCODE   DS.W 1 ; alarmCode
  262:     0002 +0001                  CDV_CNT    DS.B 1 ; cnt
  263:     0003 +0001                  CDV_RETVAL DS.B 1 ; retval
  264:     0004                        CDV_VARSIZE:
  265:     0004 +0002                  CDV_PR_X   DS.W 1 ; preserve x register
  266:     0006 +0002                  CDV_RA     DS.W 1 ; return address
  267:                                 
  268:     22FA 34                     isCodeValid: pshx
  269:     22FB 1B 9C                     leas -CDV_VARSIZE,SP
  270:     22FD 6C 80                     std CDV_ALARMCODE,SP
  271:                                    ; int *ptr;  // pointer to alarmCodes
  272:     22FF 1808 82 05                movb #NUMCODES,CDV_CNT,SP ; byte cnt = 5;
  273:     2303 1808 83 00                movb #FALSE,CDV_RETVAL,SP ; byte retval = FALSE;
  274:     2307 CE 2463                   ldx #alarmCodes           ; ptr = alarmCodes;
  275:     230A                        cdv_while                    ; do
  276:     230A EC 31                     ldd 2,X+                  ; {
  277:     230C AC 80                     cpd CDV_ALARMCODE,SP      ;    if(*ptr++ == alarmCode)
  278:     230E 26 06                     bne cdv_endif             ;    {
  279:     2310 1808 83 01                movb #TRUE,CDV_RETVAL,SP  ;      retval = TRUE;
  280:     2314 20 04                     bra cdv_endwhile          ;      break;
  281:     2316                        cdv_endif:                   ;    }
  282:     2316 63 82                     dec CDV_CNT,SP            ;   cnt--;
  283:     2318 26 F0                     bne cdv_while             ; } while(cnt != 0); 
  284:     231A                        cdv_endwhile:
  285:     231A A6 83                     ldaa CDV_RETVAL,SP         ;   return(retval);
  286:                                    ; restore registers and stack
  287:     231C 1B 84                     leas CDV_VARSIZE,SP 
  288:     231E 30                        pulx
  289:     231F 3D                        rts
  290:                                 
  291:                                 ;----------------------------
  292:                                 ; Subroutine: triggerAlarm
  293:                                 ; Parameters: none
  294:                                 ; Returns: nothing
  295:                                 ; Local Variables: retval, dobel, input - on stack
  296:                                 ; Description: Repeatedly sends a bel character to the
  297:                                 ;              terminal until a valid alarm code is entered.
  298:                                 ;----------------------------
  299:                                 ; Stack usage
  300:                                         OFFSET 0
  301:     0000 +0002                  TRA_DONE   DS.W 1 ; done
  302:     0002 +0001                  TRA_DONEINPUT  DS.B 1 ; doneInput
  303:     0003 +0001                  TRA_INPUT  DS.B 1 ; input
  304:     0004                        TRA_VARSIZE:
  305:     0004 +0002                  TRA_PR_D   DS.W 1 ; preserve D register
  306:     0006 +0002                  TRA_RA     DS.W 1 ; return address
  307:                                 
  308:     2320 3B                     triggerAlarm: pshd
  309:     2321 1B 9C                     leas -TRA_VARSIZE,SP
  310:     2323 1808 80 00                movb #FALSE,TRA_DONE,SP   ; byte done = FALSE;
  311:                                                              ; byte dobel;
  312:                                                              ; byte input;
  313:     2327                        tra_while:                   ; while(!done)
  314:     2327 E7 80                     tst TRA_DONE,SP         ; {
  315:     2329 26 38                     bne tra_endwhile
  316:     232B C6 07                     ldb #BEL                  ;    putchar(BEL);
  317:     232D 87                        clra
  318:     232E 15 FB CB54                jsr [putchar, PCr]
  319:     2332 CC 03E8                   ldd #BEEPDELAY            ;    setDelay(BEEPDELAY);   // 1 sec between beeps
  320:     2335 16 240F                   jsr setDelay
  321:     2338 1808 82 00                movb #FALSE,TRA_DONEINPUT,SP ; doneInput = FALSE;
  322:     233C                        tra_while2:                  ;    while(!doneInput) 
  323:     233C E7 82                     tst TRA_DONEINPUT,SP      ;    {
  324:     233E 26 21                     bne tra_endwhile2
  325:     2340 16 2413                   jsr polldelay             ;       doneInput = delay();
  326:     2343 6A 82                     staa TRA_DONEINPUT,SP
  327:     2345 16 2372                   jsr pollReadKey           ;       input = pollReadKey();  // check if code entered to disarm
  328:     2348 6B 83                     stab TRA_INPUT,SP
  329:     234A 180F                      tba
  330:     234C 81 23                     cmpa #'#'                 ;       if(isdigit(input) || input == '#') 
  331:     234E 27 08                     beq tra_blk1
  332:     2350 16 2435                   jsr isdigit
  333:     2353 97                        tsta
  334:     2354 26 02                     bne tra_blk1
  335:     2356 20 07                     bra tra_endif   
  336:     2358                        tra_blk1:
  337:     2358 A6 83                     ldaa TRA_INPUT,SP
  338:     235A 16 229F                   jsr checkCode             ;                done = checkCode(input);
  339:     235D 6A 80                     staa TRA_DONE,SP 
  340:     235F                        tra_endif: 
  341:     235F 20 DB                     bra tra_while2
  342:     2361                        tra_endwhile2                ;    }
  343:     2361 20 C4                     bra tra_while
  344:     2363                        tra_endwhile                 ; }
  345:     2363 1B 84                     leas TRA_VARSIZE,SP
  346:     2365 3A                        puld
  347:     2366 3D                        rts
  348:                                 
  349:                                 ;-------------------------------------------------------------------------
  350:                                 ; Data Structures
  351:                                 ;-------------------------------------------------------------------------
  352:                                         SWITCH globalConst
  353:                                 ; Message strings
  354:     24DC 43 6F 64 65 0A 0D      CODEMSG dc.b  "Code",NL,CR,$00
           24E2 00 
  355:     24E3 2A 2A 2A 20 41 72      ARMING  dc.b  "*** Arming ***",NL,CR,$00
           24E9 6D 69 6E 67 20 2A 
           24EF 2A 2A 0A 0D 00 
  356:     24F4 2A 2A 2A 20 41 72      ARMED   dc.b  "*** Armed ***",NL,CR,$00
           24FA 6D 65 64 20 2A 2A 
           2500 2A 0A 0D 00 
  357:     2504 2D 2D 20 44 69 73      DISARMING dc.b  "-- Disarming --",NL,CR,$00
           250A 61 72 6D 69 6E 67 
           2510 20 2D 2D 0A 0D 00 
  358:                                 
  359:                                    switch globalVar
  360:     3000 03E8                   mult dc.w 1000
  361:     3002 0000                   alarmCode dc.w 0
  132:                                  INCLUDE keyPad.asm
    1:                                 ;----------------------------------------------------------------------
    2:                                 ; File: Keypad.asm
    3:                                 ; Author:
    4:                                 
    5:                                 ; Description:
    6:                                 ;  This contains the code for reading the
    7:                                 ;  16-key keypad attached to Port A
    8:                                 ;  See the schematic of the connection in the
    9:                                 ;  design document.
   10:                                 ;
   11:                                 ;  The following subroutines are provided by the module
   12:                                 ;
   13:                                 ; char pollReadKey(): to poll keypad for a keypress
   14:                                 ;                 Checks keypad for 2 ms for a keypress, and
   15:                                 ;                 returns NOKEY if no keypress is found, otherwise
   16:                                 ;                 the value returned will correspond to the
   17:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   18:                                 ; void initkey(): Initialises Port A for the keypad
   19:                                 ;
   20:                                 ; char readKey(): to read the key on the keypad
   21:                                 ;                 The value returned will correspond to the
   22:                                 ;                 ASCII code for the key, i.e. 0-9, *, # and A-D
   23:                                 ;---------------------------------------------------------------------
   24:                                 
   25:                                 ; Include header files
   26:                                     include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
   27:                                     include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   28:                                 
   29:                                 **************EQUATES**********
   30:                                 
   31:                                 
   32:                                 ;-----Conversion table
   33:          =00000010              NUMKEYS EQU     16      ; Number of keys on the keypad
   34:          =000000FF              BADCODE         EQU     $FF     ; returned of translation is unsuccessful
   35:          =00000000              NOKEY           EQU     $00   ; No key pressed during poll period
   36:          =00000001              POLLCOUNT       EQU     1     ; Number of loops to create 1 ms poll time
   37:                                 
   38:                                     SWITCH globalConst  ; Constant data
   39:                                 
   40:                                     OFFSET 0
   41:     0000 +0001                  keycodeToCharTable_keycode           ds.b 1
   42:     0001 +0001                  keycodeToCharTable_character         ds.b 1
   43:     0002 +0001                  keycodeToCharTable_structLength      ds.b 1
   44:                                 
   45:     2516 EE 31                  keycodeToCharTable: dc.b $ee,'1'
   46:     2518 ED 32                      dc.b $ed,'2'
   47:     251A EB 33                      dc.b $eb,'3'
   48:     251C E7 41                      dc.b $e7,'A'
   49:     251E DE 34                      dc.b $de,'4'
   50:     2520 DD 35                      dc.b $dd,'5'
   51:     2522 DB 36                      dc.b $db,'6'
   52:     2524 D7 42                      dc.b $d7,'B'
   53:     2526 BE 37                      dc.b $be,'7'
   54:     2528 BD 38                      dc.b $bd,'8'
   55:     252A BB 39                      dc.b $bb,'9'
   56:     252C B7 43                      dc.b $b7,'C'
   57:     252E 7E 2A                      dc.b $7e,'*'
   58:     2530 7D 30                      dc.b $7d,'0'
   59:     2532 7B 23                      dc.b $7b,'#'
   60:     2534 77 44                      dc.b $77,'D'
   61:                                     
   62:                                     SWITCH code_section  ; place in code section
   63:                                 ;-----------------------------------------------------------    
   64:                                 ; Subroutine: initKeyPad
   65:                                 ;
   66:                                 ; Description: 
   67:                                 ;       Initiliases PORT A
   68:                                 ;-----------------------------------------------------------    
   69:     2367 180B F0 0002           initKeyPad: movb #$f0,DDRA
   70:     236C 180B 01 000C               movb #$01,PUCR
   71:     2371 3D                         rts
   72:                                 
   73:                                 ;-----------------------------------------------------------    
   74:                                 ; Subroutine: ch <- pollReadKey
   75:                                 ; Parameters: none
   76:                                 ; Local variable:
   77:                                 ;   c - ASCII Code in accumulator B
   78:                                 ; Returns
   79:                                 ;   c: NOKEY when no key pressed,
   80:                                 ;       otherwise, ASCII Code in accumulator B
   81:                                 
   82:                                 ; Description:
   83:                                 ;  Loops for a period of 2ms, checking to see if
   84:                                 ;  key is pressed. Calls readKey to read key if keypress 
   85:                                 ;  detected (and debounced) on Port A and get ASCII code for
   86:                                 ;  key pressed.
   87:                                 ;-----------------------------------------------------------
   88:                                 ; Stack Usage
   89:                                     OFFSET 0  ; to setup offset into stack
   90:     0000 +0001                  PRK_count   DS.B    1
   91:     0001                        PRK_VARSIZE:
   92:     0001 +0001                  PRK_PR_A    DS.B    1
   93:     0002 +0002                  PRK_RA      DS.W    1
   94:                                 
   95:          =0000000F              PRK_PORTA_CONST EQU $0f
   96:                                 
   97:     2372 36                     pollReadKey: psha
   98:     2373 1B 9F                      leas -PRK_VARSIZE,SP
   99:                                     
  100:     2375 CC 0001                    ldd #1                        ; setDelay(1);
  101:     2378 16 240F                    jsr setDelay
  102:                                     
  103:     237B 86 0F                      ldaa #PRK_PORTA_CONST
  104:     237D 5A 00                      staa PORTA                    ; PORTA = 0x0f;
  105:     237F C7                         clrb                          ; c = '\0';
  106:                                     
  107:     2380 1808 80 02                 movb #2,PRK_count,SP          ; count = 2;
  108:     2384                        PRK_DO:                           ; do
  109:                                                                   ; {
  110:     2384 91 00                      cmpa PORTA                    ;     if (PORTA != 0x0f)
  111:     2386 27 0C                      beq PRK_IF_1_END              ;     {
  112:     2388                        PRK_IF_1:
  113:     2388 16 2413                    jsr pollDelay                 ;         pollDelay();
  114:     238B 91 00                      cmpa PORTA
  115:     238D 27 05                      beq PRK_IF_2_END              ;         if (PORTA != 0x0f)
  116:     238F                        PRK_IF_2:                         ;         {
  117:     238F 16 239C                    jsr readKey                   ;             c = readKey();
  118:     2392 20 04                      bra PRK_DO_END                ;             break;
  119:     2394                        PRK_IF_2_END:                     ;         }
  120:     2394                        PRK_IF_1_END:                     ;     }
  121:     2394 63 80                      dec PRK_count,SP              ; }
  122:     2396 26 EC                      bne PRK_DO                    ; while (--count);
  123:     2398                        PRK_DO_END:
  124:                                 
  125:     2398 1B 81                      leas PRK_VARSIZE,SP
  126:     239A 32                         pula
  127:     239B 3D                         rts                           ; return c;
  128:                                 
  129:                                 ;-----------------------------------------------------------    
  130:                                 ; Subroutine: ch <- readKey
  131:                                 ; Arguments: none
  132:                                 ; Local variable: 
  133:                                 ;   c - ASCII Code in accumulator B
  134:                                 
  135:                                 ; Description:
  136:                                 ;  Main subroutine that reads a code from the
  137:                                 ;  keyboard using the subroutine readKeybrd.  The
  138:                                 ;  code is then translated with the subroutine
  139:                                 ;  translate to get the corresponding ASCII code.
  140:                                 ;-----------------------------------------------------------    
  141:                                 ; Stack Usage
  142:                                     OFFSET 0  ; to setup offset into stack
  143:     0000 +0001                  RK_code     DS.B    1
  144:     0001                        RK_VARSIZE:
  145:     0001 +0001                  RK_PR_A     DS.B    1
  146:     0002 +0002                  RK_RA       DS.W    1
  147:                                 
  148:          =0000000F              RK_PORTA_CONST EQU $0f
  149:                                 
  150:     239C 36                     readKey: psha
  151:     239D 1B 9F                      leas -RK_VARSIZE,SP
  152:                                     
  153:     239F CC 0010                    ldd #$10                        ; setDelay(10);
  154:     23A2 16 240F                    jsr setDelay
  155:                                     
  156:     23A5 C7                         clrb                            ; code = 0x00;
  157:     23A6                        RK_DO:                              ; do
  158:                                                                     ; {
  159:     23A6 180B 0F 0000               movb #RK_PORTA_CONST, PORTA     ;     PORTA = 0x0f;
  160:     23AB                        RK_WHILE_1:                         ;     while (PORTA == 0x0f);
  161:     23AB 86 0F                      ldaa #RK_PORTA_CONST
  162:     23AD 91 00                      cmpa PORTA
  163:     23AF 27 FA                      beq RK_WHILE_1
  164:     23B1                        RK_WHILE_1_END:
  165:     23B1 1809 80 0000               movb PORTA,RK_code,SP           ;     code = PORTA;
  166:     23B6 16 2413                    jsr pollDelay                   ;     pollDelay();
  167:     23B9                        RK_DO_END:                          ; }
  168:     23B9 A6 80                      ldaa RK_code,SP
  169:     23BB 91 00                      cmpa PORTA                      ; while (code != PORTA);
  170:     23BD 26 E7                      bne RK_DO
  171:                                     
  172:     23BF 16 23D4                    jsr readKeybrd                  ; c = readKeybrd();
  173:     23C2 86 0F                      ldaa #RK_PORTA_CONST
  174:     23C4 5A 00                      staa PORTA                      ; PORTA = 0x0f;
  175:     23C6                        RK_WHILE_2:                         ; while (c != PORTA);
  176:     23C6 D1 00                      cmpb PORTA
  177:     23C8 26 FC                      bne RK_WHILE_2
  178:     23CA                        RK_WHILE_2_END:
  179:     23CA 16 2413                    jsr pollDelay                   ; pollDelay();
  180:     23CD 16 23F6                    jsr translate                   ; c = translate(code);
  181:                                 
  182:     23D0 1B 81                      leas RK_VARSIZE,SP
  183:     23D2 32                         pula
  184:     23D3 3D                         rts                             ; return code; 
  185:                                 
  186:                                 
  187:                                 ;-----------------------------------------------------------    
  188:                                 ; Subroutine: ch <- readKeybrd
  189:                                 ; Arguments: none
  190:                                 ; Local variable: 
  191:                                 ;   code - Keycode in accumulator B
  192:                                 
  193:                                 ; Description:
  194:                                 ;   Read a keycode from the keyboard in accumulator B
  195:                                 ;-----------------------------------------------------------    
  196:                                 ; Stack Usage
  197:                                     OFFSET 0  ; to setup offset into stack
  198:     0000                        RKB_VARSIZE:
  199:     0000 +0002                  RKB_PR_A    DS.W    1
  200:     0002 +0002                  RKB_RA      DS.W    1
  201:                                 
  202:          =000000EF              RKB_ROW1    EQU    $ef
  203:          =000000DF              RKB_ROW2    EQU    $df
  204:          =000000BF              RKB_ROW3    EQU    $bf
  205:          =0000007F              RKB_ROW4    EQU    $7f
  206:                                 
  207:     23D4 36                     readKeybrd: psha
  208:                                     ;leas -RKB_VARSIZE,SP
  209:                                 
  210:     23D5 86 EF                      ldaa #RKB_ROW1
  211:     23D7 5A 00                      staa PORTA                      ; PORTA = ROW1;
  212:     23D9 91 00                      cmpa PORTA                      ; if (PORTA == ROW1)
  213:     23DB 26 15                      bne RKB_IF_1_END
  214:     23DD                        RKB_IF_1:                           ; {
  215:     23DD 86 DF                      ldaa #RKB_ROW2
  216:     23DF 5A 00                      staa PORTA                      ;     PORTA = ROW2;
  217:     23E1 91 00                      cmpa PORTA                      ;     if (PORTA == ROW2)
  218:     23E3 26 0D                      bne RKB_IF_2_END
  219:     23E5                        RKB_IF_2:                           ;     {
  220:     23E5 86 BF                      ldaa #RKB_ROW3
  221:     23E7 5A 00                      staa PORTA                      ;         PORTA = ROW3;
  222:     23E9 91 00                      cmpa PORTA                      ;         if (PORTA == ROW3)
  223:     23EB 26 05                      bne RKB_IF_3_END
  224:     23ED                        RKB_IF_3:
  225:     23ED 180B 7F 0000               movb #RKB_ROW4,PORTA            ;             PORTA = ROW4;
  226:     23F2                        RKB_IF_3_END:
  227:     23F2                        RKB_IF_2_END:                       ;     }
  228:     23F2                        RKB_IF_1_END:                       ; }
  229:     23F2 D6 00                      ldab PORTA                      ; code = PORTA;
  230:                                     
  231:                                     ;leas RKB_VARSIZE,SP
  232:     23F4 32                         pula
  233:     23F5 3D                         rts                             ; return code;
  234:                                 
  235:                                 ;-----------------------------------------------------------    
  236:                                 ; Subroutine: ch <- translate
  237:                                 ; Arguments:
  238:                                 ;   code - keycode in accumulator B
  239:                                 ; Local variable: 
  240:                                 ;   code - ASCII Code in accumulator B
  241:                                 ;   
  242:                                 
  243:                                 ; Description:
  244:                                 ;   Translate the keycode in accumulator B and return it back
  245:                                 ;-----------------------------------------------------------    
  246:                                 ; Stack Usage
  247:                                     OFFSET 0  ; to setup offset into stack
  248:     0000                        TRS_VARSIZE: 
  249:     0000 +0002                  TRS_PR_X    DS.W    1
  250:     0002 +0001                  TRS_PR_A    DS.B    1
  251:                                 
  252:     23F6 36                     translate: psha
  253:     23F7 34                         pshx
  254:                                     ;leas -TRS_VARSIZE,SP
  255:                                     
  256:     23F8 86 10                      ldaa #NUMKEYS
  257:     23FA CE 2516                    ldx #keycodeToCharTable                       ; keycodeToCharTablePointer = keycodeToCharTable;
  258:                                    
  259:     23FD                        TRS_LOOP:                                         ; for (int i = 0; i < NUMKEYS; ++i)
  260:     23FD                        TRS_IF:                                           ; {
  261:     23FD E1 00                      cmpb keycodeToCharTable_keycode,X             ;     if (keycodeToCharTablePointer->keycode == code)
  262:     23FF 26 04                      bne TRS_IF_FALSE
  263:     2401                        TRS_IF_TRUE:                                      ;     {
  264:     2401 E6 01                      ldab keycodeToCharTable_character,X           ;         return keycodeToCharTablePointer->character;
  265:     2403 20 07                      bra TRS_LOOP_END
  266:     2405                        TRS_IF_FALSE:                                     ;     }
  267:     2405 1A 02                      leax keycodeToCharTable_structLength,X        ;     ++keycodeToCharTablePointer;
  268:     2407 04 30 F3                   dbne A,TRS_LOOP
  269:     240A                        TRS_IF_END:                                       ; }
  270:     240A C6 FF                      ldab #BADCODE                                 ; return BADCODE;
  271:     240C                        TRS_LOOP_END:
  272:                                     
  273:                                     ;leas TRS_VARSIZE,SP
  274:     240C 30                         pulx
  275:     240D 32                         pula
  276:     240E 3D                         rts
  277:                                 
  133:                                  INCLUDE        delay.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Simulation Assembler Program
    3:                                 ; File: delay.asm
    4:                                 ; Description: The Delay Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                 ; Some definitions
   10:          =00000BB8              MSCOUNT equ 3000  ; count to create a 1 ms delay
   11:                                 
   12:                                         SWITCH code_section
   13:                                 
   14:                                 ;------------------------------------------------------
   15:                                 ; Subroutine setDelay
   16:                                 ; Parameters: cnt - accumulator D
   17:                                 ; Returns: nothing
   18:                                 ; Global Variables: delayCount
   19:                                 ; Description: Intialises the delayCount 
   20:                                 ;              variable.
   21:                                 ;------------------------------------------------------
   22:     240F                        setDelay: 
   23:     240F 7C 3004                   std delayCount     ; delayCount = cnt;
   24:     2412 3D                        rts
   25:                                 
   26:                                 
   27:                                 ;------------------------------------------------------
   28:                                 ; Subroutine: polldelay
   29:                                 ; Parameters:  none
   30:                                 ; Returns: TRUE when delay counter reaches 0 - in accumulator A
   31:                                 ; Local Variables
   32:                                 ;   retval - acc A cntr - X register
   33:                                 ; Global Variables:
   34:                                 ;      delayCount
   35:                                 ; Description: The subroutine delays for 1 ms, decrements delayCount.
   36:                                 ;              If delayCount is zero, return TRUE; FALSE otherwise.
   37:                                 ;   Core Clock is set to 24 MHz, so 1 cycle is 41 2/3 ns
   38:                                 ;   NOP takes up 1 cycle, thus 41 2/3 ns
   39:                                 ;   Need 24 cyles to create 1 microsecond delay
   40:                                 ;   8 cycles creates a 333 1/3 nano delay
   41:                                 ;       DEX - 1 cycle
   42:                                 ;       BNE - 3 cyles - when branch is taken
   43:                                 ;       Need 4 NOP
   44:                                 ;   Run Loop 3000 times to create a 1 ms delay   
   45:                                 ;------------------------------------------------------
   46:                                 ; Stack Usage:
   47:                                         OFFSET 0  ; to setup offset into stack
   48:     0000                        PDLY_VARSIZE:
   49:     0000 +0002                  PDLY_PR_Y   DS.W 1 ; preserve Y
   50:     0002 +0002                  PDLY_PR_X   DS.W 1 ; preserve X
   51:     0004 +0001                  PDLY_PR_B   DS.B 1 ; preserve B
   52:     0005 +0001                  PDLY_PR_A   DS.B 1 ; preserve A
   53:     0006 +0002                  PDLY_RA     DS.W 1 ; return address
   54:                                 
   55:     2413 36                     polldelay: psha
   56:     2414 37                        pshb
   57:     2415 34                        pshx
   58:     2416 35                        pshy
   59:     2417 86 00                     ldaa #FALSE          ; byte retval=FALSE; // return value
   60:     2419 CE 0BB8                   ldx #MSCOUNT         ; byte cntr = MSCOUNT;
   61:     241C                        pdly_while:
   62:     241C 27 07                     beq pdly_endwhile ; while(cntr != 0)
   63:                                                      ; {
   64:     241E A7                        nop               ;   asm { nop; nop; nop; nop; }
   65:     241F A7                        nop
   66:     2420 A7                        nop
   67:     2421 A7                        nop
   68:     2422 09                        dex               ;   cntr--;
   69:     2423 20 F7                     bra pdly_while    ; }
   70:     2425                        pdly_endwhile:
   71:     2425 FD 3004                   ldy delayCount    ; delayCount--;
   72:     2428 03                        dey
   73:     2429 7D 3004                   sty delayCount
   74:     242C 26 02                     bne pldy_endif    ; if(delayCount==0) 
   75:     242E 86 01                     ldaa #TRUE        ; retval=TRUE;
   76:     2430                        pldy_endif:
   77:                                    ; restore registers and stack
   78:     2430 31                        puly
   79:     2431 30                        pulx
   80:     2432 33                        pulb
   81:     2433 32                        pula
   82:     2434 3D                        rts
   83:                                 
   84:                                 
   85:                                 
   86:                                 ;------------------------------------------------------
   87:                                 ; Global variables
   88:                                 ;------------------------------------------------------
   89:                                    switch globalVar
   90:     3004 +0002                  delayCount ds.w 1   ; 2 byte delay counter
  134:                                  INCLUDE        utilities.asm
    1:                                 ;------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File: utilities.asm
    4:                                 ; Description: The Utilities Module
    5:                                 ; Author: Gilbert Arbez
    6:                                 ; Date: Fall 2010
    7:                                 ;------------------------------------------------------
    8:                                 
    9:                                         SWITCH code_section
   10:                                 
   11:                                 ;------------------------------------------------------
   12:                                 ; Subroutine isdigit
   13:                                 ; Parameters: chr - received in accumulator A/moved to B 
   14:                                 ; Returns: TRUE - chr is a digit, FALSE otherwise
   15:                                 ; Variables: retval in accumulator A
   16:                                 ; Description: Returns TRUE if chr is a digit character
   17:                                 ;              and FALSE otherwise.
   18:                                 ;------------------------------------------------------
   19:     2435 37                     isdigit: pshb   ; save B on stack
   20:     2436 180E                      tab          ; save Parameter in B
   21:     2438 86 00                     ldaa #FALSE  ;   byte retval = FALSE;
   22:     243A C1 30                     cmpb #'0'    ;   if(chr >= '0' && chr <= '9') retval = TRUE;
   23:     243C 25 06                     blo ISD_endif
   24:     243E C1 39                     cmpb #'9'
   25:     2440 22 02                     bhi ISD_endif
   26:     2442 86 01                     ldaa #TRUE
   27:     2444                        ISD_endif:
   28:     2444 33                        pulb         ; restore B
   29:     2445 3D                        rts          ; return(retval); // in A
   30:                                 
   31:                                 
   32:                                 
   33:                                 ;------------------------------------------------------
   34:                                 ; Subroutine: pollgetchar
   35:                                 ; Parameters:  none
   36:                                 ; Returns: char read from SC0 or NOCHAR if none available
   37:                                 ;          Returned in Acc A
   38:                                 ; Variables:
   39:                                 ;      ptr in X register
   40:                                 ;      sum in Accumulator B       
   41:                                 ; Description: Checks the RDRF bit to see if a character
   42:                                 ;              is available before reading a character using getchar.
   43:                                 ;------------------------------------------------------
   44:                                 
   45:     2446 36                     polgetchar: psha     ; gechar destroys contents of acc A
   46:     2447 C6 FF                    ldab #NOCHAR        ;  char chr = NOCHAR;
   47:                                   
   48:     2449 4F CC 20 04              brclr sc0sr1,%00100000,PGC_endif ; if(SCI0SR1_RDRF==1) 
   49:     244D 15 FB CA33               jsr [getchar, PCr]  ;                    chr = getchar();
   50:     2451                        PGC_endif
   51:     2451 32                        pula            ; restore registers
   52:     2452 3D                        rts             ; return(chr);  in ACC B
  135:                                  INCLUDE switches.asm
    1:                                 ;-------------------------------------------------------------
    2:                                 ; Alarm System Assembler Program
    3:                                 ; File:  switches.asm
    4:                                 ; Description: This file contains the Switches module for the
    5:                                 ;              Alarm System project.
    6:                                 ;-----------------------------------------------------------------*/
    7:                                 ; Include header files
    8:                                  include "sections.inc"
    1:                                 ;--------------------------------------
    2:                                 ; File: sections.inc
    3:                                 ; Description: Defines the sections for the project.
    4:                                 ;              Note the use of the symbol SECTIONS_DEFINED
    5:                                 ;              for conditional assembly into modules.
    6:                                 ;----------------------------------------
    7:                                 
    8:                                         IFNDEF SECTIONS_DEFINED  ; Start of conditional assembly
   50:                                          ENDIF  ; End of conditional assembly
    9:                                  include "reg9s12.inc"  ; Defines EQU's for Peripheral Ports
    1:                                 *
    2:                                 *
    3:                                 *  HC12 i/o register locations (9s12dp256)
    4:                                 *
    5:                                 
    6:                                         ifndef REG9S12  ; include only if not yet included
  485:                                         endif   ; end of conditional assembly
   10:                                 
   11:                                  SWITCH code_section  ; place in code section
   12:                                 ;----------------------------------------
   13:                                 ; Subroutine: initSwitches
   14:                                 ; Parameters: none
   15:                                 ; Returns: nothing
   16:                                 ; Description: Initialises the port for monitoring the switches
   17:                                 ;              and controlling LEDs.
   18:                                 ;----------------------------------------
   19:     2453                        initSwitches:        
   20:     2453 79 0262                   clr  DDRH         ; DDRH = 0; // set to input (switches)
   21:     2456 180B FF 0264              movb #$ff,PERH     ; PERH = 0xff; // Enable pull-up/pull-down 
   22:     245B 79 0265                   clr  PPSH     ; PPSH = 0x00; // pull-up device connected to H
   23:                                                      ;             // switches ground the pins when closed.
   24:     245E 3D                        rts
   25:                                 
   26:                                 ;------------------------
   27:                                 ; Subrooutine: getSwStatus
   28:                                 ; Parameters:  none
   29:                                 ; Returns: Acc A - An 8 bit code that indicates which
   30:                                 ;          switches are opened (bit set to 1).
   31:                                 ; Description: Checks status of switches and 
   32:                                 ;              returns bytes that shows their
   33:                                 ;              status.      
   34:                                 ;---------------------------
   35:     245F                        getSwStatus:
   36:     245F B6 0260                    ldaa PTH   ;return(PTH);
   37:     2462 3D                         rts
  136:                                 
  137:                                    switch code_section
  138:     2463                        ENDCODE ;  used to define where the dataEEPROM section starts
  139:                                         end                ; end of program

Symbols:
alarmcode                       *00003002
alarmcodes                      *00002463
armdelay                        *00000bb8
armed                           *000024f4
arming                          *000024e3
ascii_conv_num                  *00000030
badcode                         *000000ff
beepdelay                       *000003e8
bel                             *00000007
cdv_alarmcode                   *00000000
cdv_cnt                         *00000002
cdv_endif                       *00002316
cdv_endwhile                    *0000231a
cdv_retval                      *00000003
cdv_varsize                     *00000004
cdv_while                       *0000230a
cerrmsg                         *000024b1
cfg_else2                       *00002096
cfg_elseif2                     *00002088
cfg_endif1                      *000020a5
cfg_endif2                      *000020a1
cfg_flag                        *00000002
cfg_input                       *00000001
cfg_loop                        *0000206b
cfg_varsize                     *00000003
checkcode                       *0000229f
ckc_else                        *000022e6
ckc_endif                       *000022f2
ckc_endif1                      *000022e4
ckc_input                       *00000000
ckc_retval                      *00000001
ckc_varsize                     *00000002
clksel                          *00000039
codemsg                         *000024dc
configcodes                     *00002062
configmsg                       *0000249e
cr                              *0000000d
crgflg                          *00000037
ddra                            *00000002
ddrh                            *00000262
delaycount                      *00003004
disarming                       *00002504
eal_blk1                        *0000220d
eal_blk2                        *0000223f
eal_blk3                        *00002281
eal_codevalid                   *00000001
eal_delayflag                   *00000002
eal_else4                       *0000226e
eal_elseifa                     *00002247
eal_elseifb                     *0000228b
eal_endelseif                   *00002299
eal_endelseifb                  *00002299
eal_endif1                      *0000221b
eal_endif2                      *0000221b
eal_endif3                      *00002228
eal_endif4                      *00002287
eal_endif5                      *00002287
eal_endwhile1                   *000021dc
eal_endwhile2                   *0000221d
eal_endwhile3                   *0000229b
eal_endwhile4                   *00002289
eal_input                       *00000000
eal_varsize                     *00000003
eal_while1                      *000021ca
eal_while2                      *000021f1
eal_while3                      *00002228
eal_while4                      *0000225b
emc_alarmcode                   *00000003
emc_endfor                      *00002100
emc_endif2                      *000020f7
emc_endif3                      *000020f7
emc_for                         *000020c5
emc_i                           *00000001
emc_input                       *00000002
emc_mult                        *00000005
emc_retval                      *00000000
emc_varsize                     *00000007
enablealarm                     *000021bc
endcode                         *00002463
entermstcode                    *000020a9
err_mst_msg                     *000024cb
false                           *00000000
get_code_msg                    *000024bd
getchar                         *0000ee84
getswstatus                     *0000245f
inithw                          *0000202c
initkeypad                      *00002367
initswitches                    *00002453
iscodevalid                     *000022fa
isd_endif                       *00002444
isdigit                         *00002435
keycodetochartable              *00002516
keycodetochartable_character    *00000001
keycodetochartable_keycode      *00000000
keycodetochartable_structlength  *00000002
mainloop                        *0000200b
menu                            *0000246d
mnelse                          *00002029
mnelseif                        *00002020
mnendif                         *00002029
mscount                         *00000bb8
mstcdmsg                        *00002490
mult                            *00003000
nl                              *0000000a
nochar                          *000000ff
numcodes                        *00000005
numkeys                         *00000010
pdly_endwhile                   *00002425
pdly_while                      *0000241c
perh                            *00000264
pgc_endif                       *00002451
pldy_endif                      *00002430
pllctl                          *0000003a
polldelay                       *00002413
pollreadkey                     *00002372
porta                           *00000000
ppsh                            *00000265
printf                          *0000ee88
prk_count                       *00000000
prk_do                          *00002384
prk_do_end                      *00002398
prk_if_1_end                    *00002394
prk_if_2_end                    *00002394
prk_porta_const                 *0000000f
prk_varsize                     *00000001
program                         *00002000
pth                             *00000260
pucr                            *0000000c
putchar                         *0000ee86
readkey                         *0000239c
readkeybrd                      *000023d4
refdv                           *00000035
regblk                          *00000000
rk_code                         *00000000
rk_do                           *000023a6
rk_porta_const                  *0000000f
rk_varsize                      *00000001
rk_while_1                      *000023ab
rk_while_2                      *000023c6
rkb_if_1_end                    *000023f2
rkb_if_2_end                    *000023f2
rkb_if_3_end                    *000023f2
rkb_row1                        *000000ef
rkb_row2                        *000000df
rkb_row3                        *000000bf
rkb_row4                        *0000007f
sc0bdh                          *000000c8
sc0cr2                          *000000cb
sc0sr1                          *000000cc
setc_alarmcode                  *00000006
setc_digit                      *00000004
setc_else                       *00002176
setc_else2                      *0000213f
setc_elseif                     *0000214c
setc_endfor                     *00002188
setc_endif                      *0000217f
setc_endif2                     *0000214a
setc_flag                       *00000001
setc_for                        *00002127
setc_i                          *00000002
setc_input                      *00000003
setc_ix                         *00000000
setc_loop                       *0000211e
setc_mult                       *00000008
setc_varsize                    *0000000a
setcode                         *00002108
setdelay                        *0000240f
stack                           *00002000
synr                            *00000034
tra_blk1                        *00002358
tra_done                        *00000000
tra_doneinput                   *00000002
tra_endif                       *0000235f
tra_endwhile                    *00002363
tra_endwhile2                   *00002361
tra_input                       *00000003
tra_varsize                     *00000004
tra_while                       *00002327
tra_while2                      *0000233c
translate                       *000023f6
triggeralarm                    *00002320
trs_if_false                    *00002405
trs_loop                        *000023fd
trs_loop_end                    *0000240c
true                            *00000001
variables                       *00003000
wait_b3                         *00002043
wree_pr_d                       *00000000
wree_pr_x                       *00000002
writeeebyte                     *0000eea6
writetoee                       *0000219e

